
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> library(Matrix)
> source(system.file("test-tools.R", package = "Matrix"))# identical3(),
Loading required package: tools
>                                         # further  checkMatrix(), etc
> if(interactive()) options(error = recover)
> options(warn=1)# show as they happen
> cat("doExtras:",doExtras,"\n")
doExtras: FALSE 
> 
> setClass("myDGC", contains = "dgCMatrix")
> (M <- new("myDGC", as(Matrix(c(-2:4, rep(0,9)), 4), "CsparseMatrix")))
4 x 4 sparse Matrix of class "myDGC"
             
[1,] -2 2 . .
[2,] -1 3 . .
[3,]  . 4 . .
[4,]  1 . . .
> stopifnot(exprs = {
+     M[-4L, 2L] == 2:4
+     MatrixClass(     "myDGC") == "dgCMatrix"
+     MatrixClass( "dpoMatrix") == "dsyMatrix"
+     MatrixClass( "dppMatrix") == "dspMatrix"
+     MatrixClass( "corMatrix") == "dsyMatrix"
+     MatrixClass("pcorMatrix") == "dspMatrix"
+     identical(MatrixClass("indMatrix"), character(0L))
+     identical(MatrixClass(  "pMatrix"), character(0L))
+ })
> 
> ## [matrix-Bugs][6182] Coercion method doesn't work on child class
> ## Bugs item #6182, at 2015-09-01 17:49 by Vitalie Spinu
> setClass("A", contains = "ngCMatrix")
> ngc <- as(as(as(diag(3), "CsparseMatrix"), "generalMatrix"), "nMatrix")
> validObject(dd <- as(ngc, "dMatrix")) # fine
[1] TRUE
> A. <- as(ngc, "A")
> stopifnot(identical(as(A., "dMatrix"), dd))
> ## as(.) coercion failed in Matrix <= 1.2.3
> stopifnot(all( abs(A.)# failed too
+               == diag(3)))
> 
> d <- Diagonal(3)
> (dC <- as(d, "CsparseMatrix")) # "dtCMatrix" (unitriangular)
3 x 3 sparse Matrix of class "dtCMatrix" (unitriangular)
          
[1,] I . .
[2,] . I .
[3,] . . I
> (dgC <- as(dC, "generalMatrix"))
3 x 3 sparse Matrix of class "dgCMatrix"
          
[1,] 1 . .
[2,] . 1 .
[3,] . . 1
> stopifnot(exprs = {
+     is(dgC, "dgCMatrix") # was wrong in Matrix 1.3.2
+     ## identical(dgC, as(dC, "dgCMatrix")) # deprecated
+     identical(dC , new("dtCMatrix", p = rep(0L, 4), Dim = c(3L, 3L), diag = "U"))
+     identical(dC , diagN2U(as(dgC, "triangularMatrix")))
+ })
> 
> setClass("posDef", contains = "dspMatrix")
> N <- as(crossprod(M) + Diagonal(4), "packedMatrix")
> (N <- new("posDef", N))
4 x 4 Matrix of class "posDef"
     [,1] [,2] [,3] [,4]
[1,]    7   -7    0    0
[2,]   -7   30    0    0
[3,]    0    0    1    0
[4,]    0    0    0    1
> stopifnot(is(N[1:2, 1:2], "symmetricMatrix"))
> 
> #### Automatically display the class inheritance structure
> #### possibly augmented with methods
> 
> allCl <- getClasses("package:Matrix")
> cat("actual and virtual classes:\n")
actual and virtual classes:
> tt <- table( isVirt <- sapply(allCl, isVirtualClass) )
> names(tt) <- c('"actual"', "virtual")
> tt
"actual"  virtual 
      70       38 
> ## The "actual" Matrix classes:
> aCl <- allCl[!isVirt]
> (aMcl <- aCl[grep("Matrix$", aCl)]) # length 48
 [1] "lgeMatrix"  "dtrMatrix"  "dgRMatrix"  "lspMatrix"  "lsTMatrix" 
 [6] "dtTMatrix"  "dtpMatrix"  "lgTMatrix"  "dgeMatrix"  "dsTMatrix" 
[11] "dspMatrix"  "lgCMatrix"  "dgTMatrix"  "lsyMatrix"  "dgCMatrix" 
[16] "indMatrix"  "dsyMatrix"  "ntRMatrix"  "ntCMatrix"  "nsRMatrix" 
[21] "lsCMatrix"  "pcorMatrix" "ntrMatrix"  "ngRMatrix"  "pMatrix"   
[26] "dsCMatrix"  "dpoMatrix"  "ntTMatrix"  "ntpMatrix"  "ldiMatrix" 
[31] "ngeMatrix"  "nsTMatrix"  "nspMatrix"  "dppMatrix"  "ddiMatrix" 
[36] "ngTMatrix"  "ngCMatrix"  "nsyMatrix"  "corMatrix"  "nsCMatrix" 
[41] "ltRMatrix"  "ltCMatrix"  "ndiMatrix"  "lsRMatrix"  "dtRMatrix" 
[46] "ltrMatrix"  "lgRMatrix"  "dtCMatrix"  "dsRMatrix"  "ltTMatrix" 
[51] "ltpMatrix" 
> aMc2 <-  aCl[sapply(aCl, extends, class2 = "Matrix")]
> stopifnot(all( aMcl %in% aMc2 ))
> aMc2[!(aMc2 %in% aMcl)] ## only 4 : p?Cholesky & p?BunchKaufman
character(0)
> 
> ## Really nice would be to construct an inheritance graph and display
> ## it.  Following things are computational variations on the theme..
> 
> ## We use a version of  canCoerce()  that works with two *classes* instead of
> ## canCoerce <- function (object, Class)
> classCanCoerce <- function (class1, class2)
+ {
+     extends(class1, class2) ||
+     !is.null(selectMethod("coerce", optional = TRUE,
+ 			  signature    = c(from = class1, to = class2),
+ 			  useInherited = c(from = TRUE,	  to = FALSE)))
+ }
> .dq <- function(ch) paste0('"', ch, '"')
> .subclasses <- function(cnam) {
+     cd <- getClass(cnam)
+     unique(c(cd@className, unlist(lapply(names(cd@subclasses), .subclasses))))
+ }
> for(n in allCl) {
+     if(isVirtualClass(n))
+         cat("Virtual class", .dq(n),"\n")
+     else {
+         cat("\"Actual\" class", .dq(n),":\n")
+         x <- new(n)
+         if(doExtras) for(m in allCl)
+             if(classCanCoerce(n,m)) {
+                 ext <- extends(n, m)
+                 if(ext) {
+                     cat(sprintf("   extends  %20s %20s \n", "", .dq(m)))
+                 } else {
+                     cat(sprintf("   can coerce: %20s -> %20s: ", .dq(n), .dq(m)))
+                     tt <- try(as(x, m), silent = TRUE)
+                     if(inherits(tt, "try-error")) {
+                         cat("\t *ERROR* !!\n")
+                     } else {
+                         cat("as() ok; validObject: ")
+                         vo <- validObject(tt, test = TRUE)
+                         cat(if(isTRUE(vo)) "ok" else paste("OOOOOOPS:", vo), "\n")
+                     }
+                 }
+             }
+         cat("---\n")
+     }
+ }
Virtual class "index" 
"Actual" class "rleDiff" :
---
"Actual" class "lgeMatrix" :
---
"Actual" class "dtrMatrix" :
---
"Actual" class "dgRMatrix" :
---
Virtual class "QR" 
"Actual" class "dCHMsimpl" :
---
"Actual" class "lspMatrix" :
---
"Actual" class "lsTMatrix" :
---
"Actual" class "sparseLU" :
---
"Actual" class "dtTMatrix" :
---
"Actual" class "dtpMatrix" :
---
"Actual" class "lgTMatrix" :
---
Virtual class "CsparseMatrix" 
"Actual" class "dgeMatrix" :
---
Virtual class "triangularMatrix" 
Virtual class "sparseVector" 
"Actual" class "dsTMatrix" :
---
"Actual" class "dspMatrix" :
---
Virtual class "generalMatrix" 
Virtual class "CHMfactor" 
"Actual" class "lgCMatrix" :
---
"Actual" class "dgTMatrix" :
---
"Actual" class "BunchKaufman" :
---
"Actual" class "lsyMatrix" :
---
Virtual class "SchurFactorization" 
"Actual" class "sparseQR" :
---
Virtual class "CholeskyFactorization" 
"Actual" class "dgCMatrix" :
---
Virtual class "RsparseMatrix" 
Virtual class "diagonalMatrix" 
"Actual" class "indMatrix" :
---
"Actual" class "dsyMatrix" :
---
"Actual" class "ntRMatrix" :
---
Virtual class "TsparseMatrix" 
"Actual" class "ntCMatrix" :
---
"Actual" class "nCHMsimpl" :
---
"Actual" class "pBunchKaufman" :
---
Virtual class "atomicVector" 
Virtual class "replValue" 
"Actual" class "nsRMatrix" :
---
"Actual" class "lsCMatrix" :
---
Virtual class "dsparseMatrix" 
Virtual class "nsparseMatrix" 
"Actual" class "pcorMatrix" :
---
"Actual" class "ntrMatrix" :
---
"Actual" class "ngRMatrix" :
---
"Actual" class "pMatrix" :
---
"Actual" class "dCHMsuper" :
---
Virtual class "sparseMatrix" 
"Actual" class "dsCMatrix" :
---
"Actual" class "dpoMatrix" :
---
"Actual" class "ntTMatrix" :
---
"Actual" class "ntpMatrix" :
---
"Actual" class "ldiMatrix" :
---
"Actual" class "ngeMatrix" :
---
"Actual" class "nsTMatrix" :
---
"Actual" class "nspMatrix" :
---
Virtual class "lsparseMatrix" 
"Actual" class "dppMatrix" :
---
Virtual class "MatrixFactorization" 
"Actual" class "ddiMatrix" :
---
Virtual class "symmetricMatrix" 
"Actual" class "ngTMatrix" :
---
Virtual class "ddenseMatrix" 
"Actual" class "abIndex" :
---
Virtual class "lMatrix" 
"Actual" class "ngCMatrix" :
---
Virtual class "LU" 
Virtual class "compMatrix" 
Virtual class "zMatrix" 
Virtual class "nMatrix" 
"Actual" class "dsparseVector" :
---
Virtual class "Matrix" 
"Actual" class "nsyMatrix" :
---
Virtual class "iMatrix" 
Virtual class "unpackedMatrix" 
Virtual class "denseMatrix" 
"Actual" class "Cholesky" :
---
Virtual class "dMatrix" 
"Actual" class "nsparseVector" :
---
"Actual" class "corMatrix" :
---
Virtual class "CHMsimpl" 
"Actual" class "lsparseVector" :
---
"Actual" class "nsCMatrix" :
---
"Actual" class "isparseVector" :
---
"Actual" class "pCholesky" :
---
Virtual class "CHMsuper" 
Virtual class "ndenseMatrix" 
Virtual class "ldenseMatrix" 
Virtual class "BunchKaufmanFactorization" 
"Actual" class "ltRMatrix" :
---
"Actual" class "zsparseVector" :
---
"Actual" class "ltCMatrix" :
---
"Actual" class "ndiMatrix" :
---
"Actual" class "denseLU" :
---
Virtual class "number" 
"Actual" class "lsRMatrix" :
---
"Actual" class "dtRMatrix" :
---
"Actual" class "Schur" :
---
"Actual" class "ltrMatrix" :
---
"Actual" class "lgRMatrix" :
---
"Actual" class "dtCMatrix" :
---
"Actual" class "nCHMsuper" :
---
Virtual class "packedMatrix" 
"Actual" class "dsRMatrix" :
---
"Actual" class "ltTMatrix" :
---
"Actual" class "ltpMatrix" :
---
> 
> cat('Time elapsed: ', proc.time(),'\n') # for the above "part I"
Time elapsed:  1.821 0.16 1.882 0.008 0 
> 
> 
> if(doExtras && !interactive()) { # don't want to see on source()
+ 
+ cat("All classes in the 'Matrix' package:\n")
+ for(cln in allCl) {
+     cat("\n-----\n\nClass", dQuote(cln),":\n      ",
+         paste(rep("~",nchar(cln)),collapse=''),"\n")
+     ## A smarter version would use  getClass() instead of showClass(),
+     ## build the "graph" and only then display.
+     ##
+     showClass(cln)
+ }
+ 
+ cat("\n\n")
+ 
+ ## One could extend the `display' by using (something smarter than)
+ ## are the "coerce" methods showing more than the 'Extends' output above?
+ cat("All (S4) methods in the 'Matrix' package:\n")
+ showMethods(where="package:Matrix")
+ 
+ } # end{non-interactive}
> 
> ## 1-indexing instead of 0-indexing for direct "dgT" should give error:
> ii <- as.integer(c(1,2,2))
> jj <- as.integer(c(1,1,3))
> assertError(new("dgTMatrix",  i=ii, j=jj,        x= 10*(1:3), Dim=2:3))
> assertError(new("dgTMatrix",  i=ii, j=jj - 1:1,  x= 10*(1:3), Dim=2:3))
> assertError(new("dgTMatrix",  i=ii - 1:1, j=jj,  x= 10*(1:3), Dim=2:3))
> (mm <- new("dgTMatrix",  i=ii - 1:1, j=jj - 1:1, x= 10*(1:3), Dim=2:3))
2 x 3 sparse Matrix of class "dgTMatrix"
            
[1,] 10 .  .
[2,] 20 . 30
> validObject(mm)
[1] TRUE
> 
> ### Sparse Logical:
> m <- Matrix(c(0,0,2:0), 3,5)
> mT <- as(mC <- as(m, "CsparseMatrix"), "TsparseMatrix")
> stopifnot(identical(as(mT,"CsparseMatrix"), mC))
> (mC. <- as(mT[1:2, 2:3], "CsparseMatrix"))
2 x 2 sparse Matrix of class "dgCMatrix"
        
[1,] 1 .
[2,] . 2
> (mlC <- as(mC. , "lMatrix"))
2 x 2 sparse Matrix of class "lgCMatrix"
        
[1,] | .
[2,] . |
> as(mlC, "triangularMatrix")
2 x 2 sparse Matrix of class "ltCMatrix"
        
[1,] | .
[2,] . |
> 
> if(!doExtras && !interactive()) q("no") ## (saving testing time)
